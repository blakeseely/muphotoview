\section{NSObject(MUPhoto\-View\-Delegate) Category Reference}
\label{category_n_s_object(_m_u_photo_view_delegate)}\index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhotoViewDelegate)}}
The MUPhoto\-View\-Delegate category defines the methods that a {\bf MUPhoto\-View}{\rm (p.\,\pageref{interface_m_u_photo_view})} may call, and that you can use provide drag and drop, double-click, selection and even photo display support.  


{\tt \#import $<$MUPhoto\-View.h$>$}

\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
(unsigned) - {\bf photo\-Count\-For\-Photo\-View:}
\item 
(NSImage $\ast$) - {\bf photo\-View:photo\-At\-Index:}
\item 
(NSImage $\ast$) - {\bf photo\-View:fast\-Photo\-At\-Index:}
\item 
(NSIndex\-Set $\ast$) - {\bf selection\-Indexes\-For\-Photo\-View:}
\item 
(NSIndex\-Set $\ast$) - {\bf photo\-View:will\-Set\-Selection\-Indexes:}
\item 
(void) - {\bf photo\-View:did\-Set\-Selection\-Indexes:}
\item 
(unsigned int) - {\bf photo\-View:dragging\-Source\-Operation\-Mask\-For\-Local:}
\item 
(NSArray $\ast$) - {\bf pasteboard\-Drag\-Types\-For\-Photo\-View:}
\item 
(NSData $\ast$) - {\bf photo\-View:pasteboard\-Data\-For\-Photo\-At\-Index:data\-Type:}
\item 
(void) - {\bf photo\-View:double\-Click\-On\-Photo\-At\-Index:}
\item 
(NSIndex\-Set $\ast$) - {\bf photo\-View:will\-Remove\-Photos\-At\-Indexes:}
\item 
(void) - {\bf photo\-View:did\-Remove\-Photos\-At\-Indexes:}
\end{CompactItemize}


\subsection{Detailed Description}
The MUPhoto\-View\-Delegate category defines the methods that a {\bf MUPhoto\-View}{\rm (p.\,\pageref{interface_m_u_photo_view})} may call, and that you can use provide drag and drop, double-click, selection and even photo display support. 

The MUPhoto\-View\-Delegate category provides default implementations of all the methods the {\bf MUPhoto\-View}{\rm (p.\,\pageref{interface_m_u_photo_view})} may call. Overriding each of them is optional - the default implementations return no results, nil results, or zero as appropriate. 



\subsection{Member Function Documentation}
\index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!pasteboardDragTypesForPhotoView:@{pasteboardDragTypesForPhotoView:}}
\index{pasteboardDragTypesForPhotoView:@{pasteboardDragTypesForPhotoView:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (NSArray $\ast$) pasteboard\-Drag\-Types\-For\-Photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}}\label{category_n_s_object(_m_u_photo_view_delegate)_3c401ecbd6bc8839e0886e4c672fbce6}


The view will call this method at drag time. The delegate should pass an array indicating the types that it will put on the pasteboard for a given set of images. If you provide an implementation for -photo\-View:dragging\-Source\-Operation\-Mask\-For\-Local: that returns anything other than NO, you should also implement this method and indicate which types you will support. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoCountForPhotoView:@{photoCountForPhotoView:}}
\index{photoCountForPhotoView:@{photoCountForPhotoView:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (unsigned) photo\-Count\-For\-Photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}}\label{category_n_s_object(_m_u_photo_view_delegate)_5012fd973adbcb5165b0a830b46100f0}


The view will call this method if all of the following are true: (a) a valid array of NSImage objects has not been bound to the @\char`\"{}photos\-Array\char`\"{} key, (b) -set\-Photos\-Array: has not been called and passed a valid, non-nil array, and (c) the delegate is not nil. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoView:didRemovePhotosAtIndexes:@{photoView:didRemovePhotosAtIndexes:}}
\index{photoView:didRemovePhotosAtIndexes:@{photoView:didRemovePhotosAtIndexes:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (void) photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}(NSIndex\-Set $\ast$) {\em indexes}}\label{category_n_s_object(_m_u_photo_view_delegate)_737863e6e2870e2aa5bb7ce21fc686ec}


The view will call this delegate method when the user selects photos and presses the delete key. The view will first call the will\-Remove\-Photos\-At\-Indexes: method to give the delegate a chance to modify the behavior. If the photo array is set via bindings, the view will remove the specified photos and then call this method. Note that in that case, the indexes passed to this method no longer have meaning because the array has already been modified. If the photos array is NOT set via bindings, the delegate should override this method and do the appropriate removals itself. The default implementation does nothing. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoView:didSetSelectionIndexes:@{photoView:didSetSelectionIndexes:}}
\index{photoView:didSetSelectionIndexes:@{photoView:didSetSelectionIndexes:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (void) photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}(NSIndex\-Set $\ast$) {\em indexes}}\label{category_n_s_object(_m_u_photo_view_delegate)_dc1847e0791f5e39310c5ca7b2caaef5}


The view will call this method if all of the following are true: (a) a valid NSIndex\-Set has not been bound to the @\char`\"{}photo\-Selection\-Indexes\char`\"{} key, (b) -set\-Photo\-Selection\-Indexes: has not been called and passed a valid, non-nil NSIndex\-SEt, and (c) the delegate is not nil. The delegate should do whatever work necessary to mark the specified indexes as selected. (i.e. a subsequent call to -selection\-Indexes\-For\-Photo\-View: should most likely return this set or an identical one. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoView:doubleClickOnPhotoAtIndex:@{photoView:doubleClickOnPhotoAtIndex:}}
\index{photoView:doubleClickOnPhotoAtIndex:@{photoView:doubleClickOnPhotoAtIndex:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (void) photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}(unsigned) {\em index}}\label{category_n_s_object(_m_u_photo_view_delegate)_b1d5136ccafab5ba223ab0f7ac70842f}


The view will call this delegate method when the user double-clicks on the photo at the specified index. If you do not wish to support any double-click behavior, then you don't need to override this method. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoView:draggingSourceOperationMaskForLocal:@{photoView:draggingSourceOperationMaskForLocal:}}
\index{photoView:draggingSourceOperationMaskForLocal:@{photoView:draggingSourceOperationMaskForLocal:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (unsigned int) photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}(BOOL) {\em is\-Local}}\label{category_n_s_object(_m_u_photo_view_delegate)_42f4131dee120657b393067d35c7c771}


A delegate would use this method to specify whether the view should support drag operations. (i.e. whether the view should allow photos to be dragged out of the view. The semantics are identical to the -[NSDragging\-Source dragging\-Source\-Operationmask\-For\-Local] \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoView:fastPhotoAtIndex:@{photoView:fastPhotoAtIndex:}}
\index{photoView:fastPhotoAtIndex:@{photoView:fastPhotoAtIndex:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (NSImage $\ast$) photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}(unsigned) {\em index}}\label{category_n_s_object(_m_u_photo_view_delegate)_3d71f3823ce78a353981136fbc18075f}


If the view depends on the delegate for photos (instead of bindings), it will call this method during a live resize operation. It expects a very small version of the photo at the specified index in order to speed drawing in the live resize. Overriding this method is optional. The default implementation returns nil, which forces the view to use the regular photos during resize. Avoid doing any time-consuming image manipulation in this method or there will be no benefit to drawing the small images. Ideally, you would only create a small version once - either ahead of time or during this call - and then reuse it. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoView:pasteboardDataForPhotoAtIndex:dataType:@{photoView:pasteboardDataForPhotoAtIndex:dataType:}}
\index{photoView:pasteboardDataForPhotoAtIndex:dataType:@{photoView:pasteboardDataForPhotoAtIndex:dataType:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (NSData $\ast$) photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}(unsigned) {\em index}(NSString $\ast$) {\em type}}\label{category_n_s_object(_m_u_photo_view_delegate)_6087d843615018dd2c384958fc5efd09}


The view will call this method when it is about to initiate a drag. It will call this method once for $\ast$each$\ast$ combination type returned from -pasteboard\-Drag\-Types\-For\-Photo\-View: and each photo currently being dragged. The delegate should return the appropriate data for the given type. If you provide any implementation of -photo\-View:dragging\-Source\-Operation\-Mask\-For\-Local that returns anything other than NO, you should also implement this method. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoView:photoAtIndex:@{photoView:photoAtIndex:}}
\index{photoView:photoAtIndex:@{photoView:photoAtIndex:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (NSImage $\ast$) photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}(unsigned) {\em index}}\label{category_n_s_object(_m_u_photo_view_delegate)_f29adaf349861b6ab7c2b427114ab73d}


The view will call this method if all of the following are true: (a) a valid array of NSImage objects has not been bound to the @\char`\"{}photos\-Array\char`\"{} key, (b) -set\-Photos\-Array: has not been called and passed a valid, non-nil array, and (c) the delegate is not nil. The delegate should return the NSImage appropriate to draw at the specified index. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoView:willRemovePhotosAtIndexes:@{photoView:willRemovePhotosAtIndexes:}}
\index{photoView:willRemovePhotosAtIndexes:@{photoView:willRemovePhotosAtIndexes:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (NSIndex\-Set $\ast$) photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}(NSIndex\-Set $\ast$) {\em indexes}}\label{category_n_s_object(_m_u_photo_view_delegate)_f33d75adf985e0ed868468aca41cc0ee}


The view will call this delegate method when the user selects photos and presses the delete key. The delegate should use this method to alter the photos that will be removed by returning an appropriate NSIndex\-Set. The delegate will get this method even if the photos array is set via bindings. If the photos array is not set via bindings, overriding this method is still optional. The default implementation of this method simply returns the an empty index set. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!photoView:willSetSelectionIndexes:@{photoView:willSetSelectionIndexes:}}
\index{photoView:willSetSelectionIndexes:@{photoView:willSetSelectionIndexes:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (NSIndex\-Set $\ast$) photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}(NSIndex\-Set $\ast$) {\em indexes}}\label{category_n_s_object(_m_u_photo_view_delegate)_cc75f4ee5d3ecd0c2c37c0b26f6bf08c}


The view will call this method if all of the following are true: (a) a valid NSIndex\-Set has not been bound to the @\char`\"{}photo\-Selection\-Indexes\char`\"{} key, (b) -set\-Photo\-Selection\-Indexes: has not been called and passed a valid, non-nil NSIndex\-Set, and (c) the delegate is not nil. If the delegate implements this method, it can modify the proposed selection and return an appropriate NSIndex\-Set. You should only implement this method if, for some reason, you want to manipulate or look at the selection indexes before the view marks them as selected. \index{NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}!selectionIndexesForPhotoView:@{selectionIndexesForPhotoView:}}
\index{selectionIndexesForPhotoView:@{selectionIndexesForPhotoView:}!NSObject(MUPhotoViewDelegate)@{NSObject(MUPhoto\-View\-Delegate)}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}- (NSIndex\-Set $\ast$) selection\-Indexes\-For\-Photo\-View: ({\bf MUPhoto\-View} $\ast$) {\em view}}\label{category_n_s_object(_m_u_photo_view_delegate)_aba153f99799dc20969fd3538cbc92ea}


The view will call this method if all of the following are true: (a) a valid NSIndex\-Set has not been bound to the @\char`\"{}photo\-Selection\-Indexes\char`\"{} key, (b) -set\-Photo\-Selection\-Indexes: has not been called and passed a valid, non-nil NSIndex\-Set, and (c) the delegate is not nil. The delegate should return an NSIndex\-Set filled with indexes appropriately representing which photos should be drawn as \char`\"{}selected\char`\"{} . 

The documentation for this category was generated from the following file:\begin{CompactItemize}
\item 
/Users/blakeseely/Desktop/Unversioned/MUPhoto\-View Demo/MUPhoto\-View.h\end{CompactItemize}
